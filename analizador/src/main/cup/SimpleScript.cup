package org.example;

import java_cup.runtime.*;
import org.example.sym;

parser Parser;

parser code
{:
    public static int tempCount = 0;
    public static int labelCount = 0;
    private static AnalizadorLexico scanner;

    public static String newTemp() {
        return "t" + (tempCount++);
    }

    public static String newLabel() {
        return "L" + (labelCount++);
    }

    public static void setScanner(AnalizadorLexico s) {
        scanner = s;
    }

    public static int getLine() {
        return scanner.getLine();
    }

    public static void main(String[] args) throws Exception {
        try {
            AnalizadorLexico lexer = new AnalizadorLexico(new java.io.FileReader("entrada.ss"));
            setScanner(lexer);
            Parser p = new Parser(lexer);
            p.parse();
            System.out.println("\nCódigo analizado correctamente.");
        } catch (Exception e) {
            System.err.println("Error en el análisis del código:");
            e.printStackTrace();
        }
    }
:};

action code
{:
:};

terminal DEFINE, PRINT, IF, ELSE, ELSEIF, WHILE, LOOP, FUNCTION, RETURN, END, DO;
terminal TRUE, FALSE;
terminal AND, OR, NOT;
terminal PLUS, MINUS, MULT, DIV;
terminal LEQ, GEQ, EQ, NEQ, LT, GT;
terminal ASSIGN, SEMI, COMMA, LPAREN, RPAREN;
terminal Double NUMERO;
terminal String ID, CADENA;

non terminal String programa, bloque, sentencia, lista_sentencias, lista_elseif, lista_expresiones, lista_parametros, bloque_return;
non terminal String expr, expr_logica, expr_logica_aux, expr_relacional, expr_relacional_aux, expr_aritmetica, expr_aritmetica_aux, expr_primaria;

start with programa;

programa ::= bloque:b {: System.out.println(b); RESULT = b; :};

bloque ::= lista_sentencias:ls {: RESULT = ls; :};

bloque_return ::= lista_sentencias:ls RETURN expr:e SEMI
                {: String t = newTemp(); RESULT = ls + t + " = " + e + "\nreturn " + t + "\n"; :};

lista_sentencias ::= lista_sentencias:ls sentencia:s {: RESULT = ls + s; :}
                   | sentencia:s {: RESULT = s; :};

sentencia ::= DEFINE ID:id ASSIGN expr:e SEMI
            {: String t = newTemp(); RESULT = t + " = " + e + "\n" + id + " = " + t + "\n"; :}
           | PRINT lista_expresiones:le SEMI
            {: RESULT = "print " + le + "\n"; :}
           | IF expr:e DO bloque:b1 lista_elseif:lei ELSE bloque:b2 END
            {: String l1 = newLabel(), l2 = newLabel(); RESULT = "if " + e + " goto " + l1 + "\n" + b1 + "goto " + l2 + "\n" + l1 + ":\n" + lei + b2 + l2 + ":\n"; :}
           | WHILE expr:e DO bloque:b END
            {: String l1 = newLabel(), l2 = newLabel(); RESULT = l1 + ":\n" + "if not " + e + " goto " + l2 + "\n" + b + "goto " + l1 + "\n" + l2 + ":\n"; :}
           | LOOP LPAREN sentencia:s1 expr:e sentencia:s2 RPAREN bloque:b END
            {: String l1 = newLabel(), l2 = newLabel(); RESULT = s1 + l1 + ":\n" + "if not " + e + " goto " + l2 + "\n" + b + s2 + "goto " + l1 + "\n" + l2 + ":\n"; :}
           | FUNCTION ID:id LPAREN lista_parametros:lp RPAREN bloque_return:br END
            {: RESULT = "function " + id + "(" + lp + ")\n" + br + "end\n"; :}
           | error SEMI {: RESULT = "// Error en línea " + Parser.getLine() + "\n"; :};

lista_elseif ::= lista_elseif ELSEIF expr:e THEN bloque:b {: RESULT = "else if " + e + " then\\n" + b; :}
               | /* vacío */ {: RESULT = ""; :};

lista_parametros ::= lista_parametros COMMA ID:id {: RESULT = RESULT + ", " + id; :}
                   | ID:id {: RESULT = id; :}
                   | /* vacío */ {: RESULT = ""; :};

lista_expresiones ::= lista_expresiones COMMA expr:e {: RESULT = RESULT + ", " + e; :}
                    | expr:e {: RESULT = e; :}
                    | /* vacío */ {: RESULT = ""; :};

expr ::= expr_logica:e {: RESULT = e; :};

expr_logica ::= NOT expr_logica:e {: String t = newTemp(); RESULT = t + " = NOT " + e + "\n"; :}
              | expr_relacional:er expr_logica_aux:aux {: RESULT = er + aux; :};

expr_logica_aux ::= AND expr_relacional:r expr_logica_aux:aux {: String t = newTemp(); RESULT = t + " = " + r + " AND " + aux + "\n"; :}
                  | OR expr_relacional:r expr_logica_aux:aux {: String t = newTemp(); RESULT = t + " = " + r + " OR " + aux + "\n"; :}
                  | /* vacío */ {: RESULT = ""; :};

expr_relacional ::= expr_aritmetica:ea expr_relacional_aux:ra {: RESULT = ea + ra; :};

expr_relacional_aux ::= EQ expr_aritmetica:r {: String t = newTemp(); RESULT = " == " + r; :}
                      | NEQ expr_aritmetica:r {: String t = newTemp(); RESULT = " != " + r; :}
                      | LT expr_aritmetica:r {: String t = newTemp(); RESULT = " < " + r; :}
                      | GT expr_aritmetica:r {: String t = newTemp(); RESULT = " > " + r; :}
                      | LEQ expr_aritmetica:r {: String t = newTemp(); RESULT = " <= " + r; :}
                      | GEQ expr_aritmetica:r {: String t = newTemp(); RESULT = " >= " + r; :}
                      | /* vacío */ {: RESULT = ""; :};

expr_aritmetica ::= expr_primaria:e expr_aritmetica_aux:ax {: RESULT = e + ax; :};

expr_aritmetica_aux ::= PLUS expr_primaria:p expr_aritmetica_aux:ax {: String t = newTemp(); RESULT = t + " = " + p + " + " + ax + "\n" + t; :}
                      | MINUS expr_primaria:p expr_aritmetica_aux:ax {: String t = newTemp(); RESULT = t + " = " + p + " - " + ax + "\n" + t; :}
                      | MULT expr_primaria:p expr_aritmetica_aux:ax {: String t = newTemp(); RESULT = t + " = " + p + " * " + ax + "\n" + t; :}
                      | DIV expr_primaria:p expr_aritmetica_aux:ax {: String t = newTemp(); RESULT = t + " = " + p + " / " + ax + "\n" + t; :}
                      | /* vacío */ {: RESULT = ""; :};

expr_primaria ::= LPAREN expr:e RPAREN {: RESULT = "(" + e + ")"; :}
                | ID:id LPAREN lista_expresiones:args RPAREN {: String t = newTemp(); RESULT = "param " + args + "\n" + t + " = call " + id + "\n" + t; :}
                | ID:id {: RESULT = id; :}
                | NUMERO:n {: RESULT = String.valueOf(n); :}
                | TRUE {: RESULT = "true"; :}
                | FALSE {: RESULT = "false"; :}
                | CADENA:c {: RESULT = c; :};
