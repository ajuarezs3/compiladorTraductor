package org.example;

import java_cup.runtime.*;
import org.example.sym;

parser code
{:
    public static int tempCount = 0;
    private static AnalizadorLexico scanner;

    public static String newTemp() {
        return "t" + (tempCount++);
    }

    public parser(AnalizadorLexico s) {
        super(s);
        scanner = s;
    }

    public static int getLine() {
        return scanner.getLine();
    }

    public static void main(String[] args) throws Exception {
        try {
            parser p = new parser(new AnalizadorLexico(new java.io.FileReader("entrada.ss")));
            p.parse();
            System.out.println("\n✅ Código analizado correctamente.");
        } catch (Exception e) {
            System.err.println("❌ Error en el análisis del código:");
            e.printStackTrace();
        }
    }
:};

action code
{:
    // Aquí podrías manejar un generador de código TAC
:};

// Declaración de tokens
terminal DEFINE, PRINT, IF, ELSE, ELSEIF, WHILE, LOOP, FUNCTION, RETURN, END;
terminal TRUE, FALSE;
terminal AND, OR, NOT;
terminal PLUS, MINUS, MULT, DIV;
terminal LEQ, GEQ, EQ, NEQ, LT, GT;
terminal ASSIGN, SEMI, COMMA, LPAREN, RPAREN;
terminal Double NUMERO;
terminal String ID, CADENA;

// No terminales
non terminal programa, bloque, sentencia, lista_sentencias, lista_elseif, lista_expresiones;
non terminal String expr, expr_logica, expr_logica_aux, expr_relacional, expr_relacional_aux;
non terminal String expr_aritmetica, expr_aritmetica_aux, expr_primaria;

start with programa;

programa ::= bloque ;

bloque ::= lista_sentencias ;

lista_sentencias ::= lista_sentencias sentencia
                   | sentencia ;

sentencia ::= DEFINE ID:id ASSIGN expr:ex SEMI
            {:
               String temp = parser.newTemp();
               System.out.println(temp + " = " + ex);
               System.out.println(id + " = " + temp);
            :}
           | PRINT expr:ex SEMI
            {: System.out.println("print " + ex); :}
           | IF expr bloque lista_elseif ELSE bloque END
            {: System.out.println("Condicional IF-ELSEIF-ELSE evaluado"); :}
           | IF expr bloque ELSE bloque END
            {: System.out.println("Condicional IF-ELSE evaluado"); :}
           | IF expr bloque END
            {: System.out.println("Condicional IF evaluado"); :}
           | WHILE expr bloque END
            {: System.out.println("Bucle WHILE evaluado"); :}
           | LOOP LPAREN sentencia expr sentencia RPAREN bloque END
            {: System.out.println("Bucle tipo FOR evaluado"); :}
           | FUNCTION ID:id LPAREN lista_expresiones RPAREN bloque RETURN expr:ex SEMI END
            {: System.out.println("Función " + id + " definida con return " + ex); :}
           | error SEMI
            {: System.err.println("Error de sintaxis en sentencia en línea " + parser.getLine()); :};

lista_elseif ::= lista_elseif ELSEIF expr bloque
               | ELSEIF expr bloque ;

lista_expresiones ::= lista_expresiones COMMA expr
                    | expr
                    | /* vacío */ ;

expr ::= expr_logica;

expr_logica ::= NOT expr_logica:ex {: RESULT = "NOT " + ex; :}
              | expr_relacional:er expr_logica_aux:aux {: RESULT = er + aux; :};

expr_logica_aux ::= AND expr_relacional:r expr_logica_aux:aux {: RESULT = " AND " + r + aux; :}
                  | OR expr_relacional:r expr_logica_aux:aux {: RESULT = " OR " + r + aux; :}
                  | /* vacío */ {: RESULT = ""; :};

expr_relacional ::= expr_aritmetica:ea expr_relacional_aux:ra {: RESULT = ea + ra; :};

expr_relacional_aux ::= EQ expr_aritmetica:r {: RESULT = " == " + r; :}
                      | NEQ expr_aritmetica:r {: RESULT = " != " + r; :}
                      | LT expr_aritmetica:r {: RESULT = " < " + r; :}
                      | GT expr_aritmetica:r {: RESULT = " > " + r; :}
                      | LEQ expr_aritmetica:r {: RESULT = " <= " + r; :}
                      | GEQ expr_aritmetica:r {: RESULT = " >= " + r; :}
                      | /* vacío */ {: RESULT = ""; :};

expr_aritmetica ::= expr_primaria:e expr_aritmetica_aux:ax {: RESULT = e + ax; :};

expr_aritmetica_aux ::= PLUS expr_primaria:p expr_aritmetica_aux:ax
    {:
      String t = parser.newTemp();
      System.out.println(t + " = " + p + " + " + ax);
      RESULT = t;
    :}
                      | MINUS expr_primaria:p expr_aritmetica_aux:ax
    {:
      String t = parser.newTemp();
      System.out.println(t + " = " + p + " - " + ax);
      RESULT = t;
    :}
                      | MULT expr_primaria:p expr_aritmetica_aux:ax
    {:
      String t = parser.newTemp();
      System.out.println(t + " = " + p + " * " + ax);
      RESULT = t;
    :}
                      | DIV expr_primaria:p expr_aritmetica_aux:ax
    {:
      String t = parser.newTemp();
      System.out.println(t + " = " + p + " / " + ax);
      RESULT = t;
    :}
                      | /* vacío */ {: RESULT = ""; :};

expr_primaria ::= LPAREN expr:ex RPAREN {: RESULT = "(" + ex + ")"; :}
                | NUMERO:n {: RESULT = String.valueOf(n); :}
                | ID:id {: RESULT = id; :}
                | TRUE {: RESULT = "true"; :}
                | FALSE {: RESULT = "false"; :}
                | CADENA:c {: RESULT = c; :};
